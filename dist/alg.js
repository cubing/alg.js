(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["alg"] = factory();
	else
		root["alg"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./algorithm.ts":
/*!**********************!*\
  !*** ./algorithm.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar traversal_1 = __webpack_require__(/*! ./traversal */ \"./traversal.ts\");\n\"use strict\";\nvar Algorithm = /** @class */ (function () {\n    function Algorithm() {\n    }\n    // TODO: Figure out if we can statically enforce that all Algorithm subclasses\n    // are frozen after initial construction.\n    Algorithm.prototype.freeze = function () {\n        Object.freeze(this);\n    };\n    Algorithm.prototype.clone = function () { return traversal_1.Traversal.Singleton.clone.traverse(this); };\n    Algorithm.prototype.invert = function () { return traversal_1.Traversal.Singleton.invert.traverse(this); };\n    Algorithm.prototype.expand = function () { return traversal_1.Traversal.Singleton.expand.traverse(this); };\n    Algorithm.prototype.countBlockMoves = function () { return traversal_1.Traversal.Singleton.countBlockMoves.traverse(this); };\n    Algorithm.prototype.coalesceMoves = function () { return traversal_1.Traversal.Singleton.coalesceMoves.traverse(this); };\n    Algorithm.prototype.toString = function () { return traversal_1.Traversal.Singleton.toString.traverse(this); };\n    Algorithm.prototype.structureEquals = function (nestedAlg) {\n        return traversal_1.Traversal.Singleton.structureEquals.traverse(this, nestedAlg);\n    };\n    Algorithm.prototype.concat = function (nestedAlg) {\n        return traversal_1.Traversal.Singleton.concat.traverse(this, nestedAlg);\n    };\n    return Algorithm;\n}());\nexports.Algorithm = Algorithm;\nvar Repeatable = /** @class */ (function (_super) {\n    __extends(Repeatable, _super);\n    // TODO: Make `amount` an optional argument in derived class constructors.\n    function Repeatable(amount) {\n        var _this = _super.call(this) || this;\n        _this.amount = amount;\n        return _this;\n    }\n    return Repeatable;\n}(Algorithm));\nexports.Repeatable = Repeatable;\nvar Sequence = /** @class */ (function (_super) {\n    __extends(Sequence, _super);\n    function Sequence(nestedAlgs) {\n        var _this = _super.call(this) || this;\n        _this.nestedAlgs = nestedAlgs;\n        _this.type = \"sequence\";\n        _this.freeze();\n        return _this;\n    }\n    Sequence.prototype.dispatch = function (t, dataDown) {\n        return t.traverseSequence(this, dataDown);\n    };\n    return Sequence;\n}(Algorithm));\nexports.Sequence = Sequence;\n// Group is is like a Sequence, but is enclosed in parentheses when\n// written.\nvar Group = /** @class */ (function (_super) {\n    __extends(Group, _super);\n    function Group(nestedAlg, amount) {\n        var _this = _super.call(this, amount) || this;\n        _this.nestedAlg = nestedAlg;\n        _this.type = \"group\";\n        _this.freeze();\n        return _this;\n    }\n    Group.prototype.dispatch = function (t, dataDown) {\n        return t.traverseGroup(this, dataDown);\n    };\n    return Group;\n}(Repeatable));\nexports.Group = Group;\nvar BlockMove = /** @class */ (function (_super) {\n    __extends(BlockMove, _super);\n    // TODO: Handle layers in constructor\n    function BlockMove(base, amount) {\n        var _this = _super.call(this, amount) || this;\n        _this.base = base;\n        _this.type = \"blockMove\";\n        _this.freeze();\n        return _this;\n    }\n    BlockMove.prototype.dispatch = function (t, dataDown) {\n        return t.traverseBlockMove(this, dataDown);\n    };\n    return BlockMove;\n}(Repeatable));\nexports.BlockMove = BlockMove;\nvar Commutator = /** @class */ (function (_super) {\n    __extends(Commutator, _super);\n    function Commutator(A, B, amount) {\n        var _this = _super.call(this, amount) || this;\n        _this.A = A;\n        _this.B = B;\n        _this.type = \"commutator\";\n        _this.freeze();\n        return _this;\n    }\n    Commutator.prototype.dispatch = function (t, dataDown) {\n        return t.traverseCommutator(this, dataDown);\n    };\n    return Commutator;\n}(Repeatable));\nexports.Commutator = Commutator;\nvar Conjugate = /** @class */ (function (_super) {\n    __extends(Conjugate, _super);\n    function Conjugate(A, B, amount) {\n        var _this = _super.call(this, amount) || this;\n        _this.A = A;\n        _this.B = B;\n        _this.type = \"conjugate\";\n        _this.freeze();\n        return _this;\n    }\n    Conjugate.prototype.dispatch = function (t, dataDown) {\n        return t.traverseConjugate(this, dataDown);\n    };\n    return Conjugate;\n}(Repeatable));\nexports.Conjugate = Conjugate;\nvar Pause = /** @class */ (function (_super) {\n    __extends(Pause, _super);\n    function Pause() {\n        var _this = _super.call(this) || this;\n        _this.type = \"pause\";\n        _this.freeze();\n        return _this;\n    }\n    Pause.prototype.dispatch = function (t, dataDown) {\n        return t.traversePause(this, dataDown);\n    };\n    return Pause;\n}(Algorithm));\nexports.Pause = Pause;\nvar NewLine = /** @class */ (function (_super) {\n    __extends(NewLine, _super);\n    function NewLine() {\n        var _this = _super.call(this) || this;\n        _this.type = \"newLine\";\n        _this.freeze();\n        return _this;\n    }\n    NewLine.prototype.dispatch = function (t, dataDown) {\n        return t.traverseNewLine(this, dataDown);\n    };\n    return NewLine;\n}(Algorithm));\nexports.NewLine = NewLine;\nvar CommentShort = /** @class */ (function (_super) {\n    __extends(CommentShort, _super);\n    function CommentShort(comment) {\n        var _this = _super.call(this) || this;\n        _this.comment = comment;\n        _this.type = \"commentShort\";\n        _this.freeze();\n        return _this;\n    }\n    CommentShort.prototype.dispatch = function (t, dataDown) {\n        return t.traverseCommentShort(this, dataDown);\n    };\n    return CommentShort;\n}(Algorithm));\nexports.CommentShort = CommentShort;\nvar CommentLong = /** @class */ (function (_super) {\n    __extends(CommentLong, _super);\n    function CommentLong(comment) {\n        var _this = _super.call(this) || this;\n        _this.comment = comment;\n        _this.type = \"commentLong\";\n        _this.freeze();\n        return _this;\n    }\n    CommentLong.prototype.dispatch = function (t, dataDown) {\n        return t.traverseCommentLong(this, dataDown);\n    };\n    return CommentLong;\n}(Algorithm));\nexports.CommentLong = CommentLong;\n// TODO\n// export class TimeStamp extends Algorithm implements Algorithm\n\n\n//# sourceURL=webpack://alg/./algorithm.ts?");

/***/ }),

/***/ "./example.ts":
/*!********************!*\
  !*** ./example.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar algorithm_1 = __webpack_require__(/*! ./algorithm */ \"./algorithm.ts\");\n\"use strict\";\nvar Example;\n(function (Example) {\n    Example.Sune = new algorithm_1.Sequence([\n        new algorithm_1.BlockMove(\"R\", 1),\n        new algorithm_1.BlockMove(\"U\", 1),\n        new algorithm_1.BlockMove(\"R\", -1),\n        new algorithm_1.BlockMove(\"U\", 1),\n        new algorithm_1.BlockMove(\"R\", 1),\n        new algorithm_1.BlockMove(\"U\", -2),\n        new algorithm_1.BlockMove(\"R\", -1)\n    ]);\n    Example.AntiSune = new algorithm_1.Sequence([\n        new algorithm_1.BlockMove(\"R\", 1),\n        new algorithm_1.BlockMove(\"U\", 2),\n        new algorithm_1.BlockMove(\"R\", -1),\n        new algorithm_1.BlockMove(\"U\", -1),\n        new algorithm_1.BlockMove(\"R\", 1),\n        new algorithm_1.BlockMove(\"U\", -1),\n        new algorithm_1.BlockMove(\"R\", -1)\n    ]);\n    Example.SuneCommutator = new algorithm_1.Commutator(new algorithm_1.Sequence([\n        new algorithm_1.BlockMove(\"R\", 1),\n        new algorithm_1.BlockMove(\"U\", 1),\n        new algorithm_1.BlockMove(\"R\", -2)\n    ]), new algorithm_1.Sequence([\n        new algorithm_1.BlockMove(\"R\", 1),\n        new algorithm_1.BlockMove(\"U\", 1),\n        new algorithm_1.BlockMove(\"R\", -1)\n    ]), 1);\n    Example.Niklas = new algorithm_1.Sequence([\n        new algorithm_1.BlockMove(\"R\", 1),\n        new algorithm_1.BlockMove(\"U\", -1),\n        new algorithm_1.BlockMove(\"L\", -1),\n        new algorithm_1.BlockMove(\"U\", 1),\n        new algorithm_1.BlockMove(\"R\", -1),\n        new algorithm_1.BlockMove(\"U\", -1),\n        new algorithm_1.BlockMove(\"L\", 1),\n        new algorithm_1.BlockMove(\"U\", 1)\n    ]);\n    Example.FURURFCompact = new algorithm_1.Conjugate(new algorithm_1.BlockMove(\"F\", 1), new algorithm_1.Commutator(new algorithm_1.BlockMove(\"U\", 1), new algorithm_1.BlockMove(\"R\", 1), 1), 1);\n    Example.APermCompact = new algorithm_1.Conjugate(new algorithm_1.BlockMove(\"R\", 2), new algorithm_1.Commutator(new algorithm_1.BlockMove(\"F\", 2), new algorithm_1.Sequence([\n        new algorithm_1.BlockMove(\"R\", -1),\n        new algorithm_1.BlockMove(\"B\", -1),\n        new algorithm_1.BlockMove(\"R\", 1),\n    ]), 1), 1);\n    Example.FURURFMoves = new algorithm_1.Sequence([\n        new algorithm_1.BlockMove(\"F\", 1),\n        new algorithm_1.BlockMove(\"U\", 1),\n        new algorithm_1.BlockMove(\"R\", 1),\n        new algorithm_1.BlockMove(\"U\", -1),\n        new algorithm_1.BlockMove(\"R\", -1),\n        new algorithm_1.BlockMove(\"F\", -1)\n    ]);\n    Example.TPerm = new algorithm_1.Sequence([\n        new algorithm_1.BlockMove(\"R\", 1),\n        new algorithm_1.BlockMove(\"U\", 1),\n        new algorithm_1.BlockMove(\"R\", -1),\n        new algorithm_1.BlockMove(\"U\", -1),\n        new algorithm_1.BlockMove(\"R\", -1),\n        new algorithm_1.BlockMove(\"F\", 1),\n        new algorithm_1.BlockMove(\"R\", 2),\n        new algorithm_1.BlockMove(\"U\", -1),\n        new algorithm_1.BlockMove(\"R\", -1),\n        new algorithm_1.BlockMove(\"U\", -1),\n        new algorithm_1.BlockMove(\"R\", 1),\n        new algorithm_1.BlockMove(\"U\", 1),\n        new algorithm_1.BlockMove(\"R\", -1),\n        new algorithm_1.BlockMove(\"F\", -1)\n    ]);\n    Example.HeadlightSwaps = new algorithm_1.Conjugate(new algorithm_1.BlockMove(\"F\", 1), new algorithm_1.Commutator(new algorithm_1.BlockMove(\"R\", 1), new algorithm_1.BlockMove(\"U\", 1), 3), 1);\n    Example.AllAlgTypes = [\n        new algorithm_1.Sequence([new algorithm_1.BlockMove(\"R\", 1), new algorithm_1.BlockMove(\"U\", -1)]),\n        new algorithm_1.Group(new algorithm_1.BlockMove(\"F\", 1), 2),\n        new algorithm_1.BlockMove(\"R\", 2),\n        new algorithm_1.Commutator(new algorithm_1.BlockMove(\"R\", 2), new algorithm_1.BlockMove(\"U\", 2), 2),\n        new algorithm_1.Conjugate(new algorithm_1.BlockMove(\"L\", 2), new algorithm_1.BlockMove(\"D\", -1), 2),\n        new algorithm_1.Pause(),\n        new algorithm_1.NewLine(),\n        new algorithm_1.CommentShort(\"short comment\"),\n        new algorithm_1.CommentLong(\"long comment\")\n    ];\n})(Example = exports.Example || (exports.Example = {}));\n\n\n//# sourceURL=webpack://alg/./example.ts?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// TODO Figure out if we can create a default global easily.\n// export as namespace Alg;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar algorithm_1 = __webpack_require__(/*! ./algorithm */ \"./algorithm.ts\");\nexports.Algorithm = algorithm_1.Algorithm;\nexports.Repeatable = algorithm_1.Repeatable;\nexports.Sequence = algorithm_1.Sequence;\nexports.Group = algorithm_1.Group;\nexports.BlockMove = algorithm_1.BlockMove;\nexports.Commutator = algorithm_1.Commutator;\nexports.Conjugate = algorithm_1.Conjugate;\nexports.Pause = algorithm_1.Pause;\nexports.NewLine = algorithm_1.NewLine;\nexports.CommentShort = algorithm_1.CommentShort;\nexports.CommentLong = algorithm_1.CommentLong;\nvar traversal_1 = __webpack_require__(/*! ./traversal */ \"./traversal.ts\");\nexports.Traversal = traversal_1.Traversal;\nvar example_1 = __webpack_require__(/*! ./example */ \"./example.ts\");\nexports.Example = example_1.Example;\n\n\n//# sourceURL=webpack://alg/./index.ts?");

/***/ }),

/***/ "./traversal.ts":
/*!**********************!*\
  !*** ./traversal.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar algorithm_1 = __webpack_require__(/*! ./algorithm */ \"./algorithm.ts\");\n\"use strict\";\nvar Traversal;\n(function (Traversal) {\n    var DownUp = /** @class */ (function () {\n        function DownUp() {\n        }\n        // Immediate subclasses should overwrite this.\n        DownUp.prototype.traverse = function (algorithm, dataDown) {\n            return algorithm.dispatch(this, dataDown);\n        };\n        return DownUp;\n    }());\n    Traversal.DownUp = DownUp;\n    var Up = /** @class */ (function (_super) {\n        __extends(Up, _super);\n        function Up() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        Up.prototype.traverse = function (algorithm) {\n            return algorithm.dispatch(this, undefined);\n        };\n        return Up;\n    }(DownUp));\n    Traversal.Up = Up;\n    ;\n    var Clone = /** @class */ (function (_super) {\n        __extends(Clone, _super);\n        function Clone() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        Clone.prototype.traverseSequence = function (sequence) {\n            var _this = this;\n            return new algorithm_1.Sequence(sequence.nestedAlgs.map(function (a) { return _this.traverse(a); }));\n        };\n        Clone.prototype.traverseGroup = function (group) {\n            return new algorithm_1.Group(this.traverse(group.nestedAlg), group.amount);\n        };\n        Clone.prototype.traverseBlockMove = function (blockMove) {\n            return new algorithm_1.BlockMove(blockMove.base, blockMove.amount);\n        };\n        Clone.prototype.traverseCommutator = function (commutator) {\n            return new algorithm_1.Commutator(this.traverse(commutator.A), this.traverse(commutator.B), commutator.amount);\n        };\n        Clone.prototype.traverseConjugate = function (conjugate) {\n            return new algorithm_1.Conjugate(this.traverse(conjugate.A), this.traverse(conjugate.B), conjugate.amount);\n        };\n        Clone.prototype.traversePause = function (pause) { return pause; };\n        Clone.prototype.traverseNewLine = function (newLine) { return newLine; };\n        Clone.prototype.traverseCommentShort = function (commentShort) { return commentShort; };\n        Clone.prototype.traverseCommentLong = function (commentLong) { return commentLong; };\n        return Clone;\n    }(Up));\n    Traversal.Clone = Clone;\n    // TODO: Test that inverses are bijections.\n    var Invert = /** @class */ (function (_super) {\n        __extends(Invert, _super);\n        function Invert() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        Invert.prototype.traverseSequence = function (sequence) {\n            var _this = this;\n            // TODO: Handle newLines and comments correctly\n            return new algorithm_1.Sequence(sequence.nestedAlgs.slice().reverse().map(function (a) { return _this.traverse(a); }));\n        };\n        Invert.prototype.traverseGroup = function (group) {\n            return new algorithm_1.Group(this.traverse(group.nestedAlg), group.amount);\n        };\n        Invert.prototype.traverseBlockMove = function (blockMove) {\n            return new algorithm_1.BlockMove(blockMove.base, -blockMove.amount);\n        };\n        Invert.prototype.traverseCommutator = function (commutator) {\n            return new algorithm_1.Commutator(commutator.B, commutator.A, commutator.amount);\n        };\n        Invert.prototype.traverseConjugate = function (conjugate) {\n            return new algorithm_1.Conjugate(conjugate.A, this.traverse(conjugate.B), conjugate.amount);\n        };\n        Invert.prototype.traversePause = function (pause) { return pause; };\n        Invert.prototype.traverseNewLine = function (newLine) { return newLine; };\n        Invert.prototype.traverseCommentShort = function (commentShort) { return commentShort; };\n        Invert.prototype.traverseCommentLong = function (commentLong) { return commentLong; };\n        return Invert;\n    }(Up));\n    Traversal.Invert = Invert;\n    var Expand = /** @class */ (function (_super) {\n        __extends(Expand, _super);\n        function Expand() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        Expand.prototype.flattenSequenceOneLevel = function (algList) {\n            var flattened = [];\n            for (var _i = 0, algList_1 = algList; _i < algList_1.length; _i++) {\n                var part = algList_1[_i];\n                if (part instanceof algorithm_1.Sequence) {\n                    flattened = flattened.concat(part.nestedAlgs);\n                }\n                else {\n                    flattened.push(part);\n                }\n            }\n            return flattened;\n        };\n        Expand.prototype.repeat = function (algList, accordingTo) {\n            var amount = Math.abs(accordingTo.amount);\n            var amountDir = (accordingTo.amount > 0) ? 1 : -1; // Mutable\n            // TODO: Cleaner inversion\n            var once;\n            if (amountDir == -1) {\n                // TODO: Avoid casting to sequence.\n                once = (new algorithm_1.Sequence(algList)).invert().nestedAlgs;\n            }\n            else {\n                once = algList;\n            }\n            var repeated = [];\n            for (var i = 0; i < amount; i++) {\n                repeated = repeated.concat(once);\n            }\n            return new algorithm_1.Sequence(repeated);\n        };\n        Expand.prototype.traverseSequence = function (sequence) {\n            var _this = this;\n            return new algorithm_1.Sequence(this.flattenSequenceOneLevel(sequence.nestedAlgs.map(function (a) { return _this.traverse(a); })));\n        };\n        Expand.prototype.traverseGroup = function (group) {\n            // TODO: Pass raw Algorithm[] to sequence.\n            return this.repeat([this.traverse(group.nestedAlg)], group);\n        };\n        Expand.prototype.traverseBlockMove = function (blockMove) {\n            return blockMove;\n        };\n        Expand.prototype.traverseCommutator = function (commutator) {\n            var expandedA = this.traverse(commutator.A);\n            var expandedB = this.traverse(commutator.B);\n            var once = [];\n            once = once.concat(expandedA, expandedB, expandedA.invert(), expandedB.invert());\n            return this.repeat(this.flattenSequenceOneLevel(once), commutator);\n        };\n        Expand.prototype.traverseConjugate = function (conjugate) {\n            var expandedA = this.traverse(conjugate.A);\n            var expandedB = this.traverse(conjugate.B);\n            var once = [];\n            once = once.concat(expandedA, expandedB, expandedA.invert());\n            return this.repeat(this.flattenSequenceOneLevel(once), conjugate);\n        };\n        Expand.prototype.traversePause = function (pause) { return pause; };\n        Expand.prototype.traverseNewLine = function (newLine) { return newLine; };\n        Expand.prototype.traverseCommentShort = function (commentShort) { return commentShort; };\n        Expand.prototype.traverseCommentLong = function (commentLong) { return commentLong; };\n        return Expand;\n    }(Up));\n    Traversal.Expand = Expand;\n    var CountBlockMoves = /** @class */ (function (_super) {\n        __extends(CountBlockMoves, _super);\n        function CountBlockMoves() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        CountBlockMoves.prototype.traverseSequence = function (sequence) {\n            var total = 0;\n            for (var _i = 0, _a = sequence.nestedAlgs; _i < _a.length; _i++) {\n                var part = _a[_i];\n                total += this.traverse(part);\n            }\n            return total;\n        };\n        CountBlockMoves.prototype.traverseGroup = function (group) {\n            return this.traverse(group.nestedAlg);\n        };\n        CountBlockMoves.prototype.traverseBlockMove = function (blockMove) {\n            return 1;\n        };\n        CountBlockMoves.prototype.traverseCommutator = function (commutator) {\n            return 2 * (this.traverse(commutator.A) + this.traverse(commutator.B));\n        };\n        CountBlockMoves.prototype.traverseConjugate = function (conjugate) {\n            return 2 * (this.traverse(conjugate.A)) + this.traverse(conjugate.B);\n        };\n        CountBlockMoves.prototype.traversePause = function (pause) { return 0; };\n        CountBlockMoves.prototype.traverseNewLine = function (newLine) { return 0; };\n        CountBlockMoves.prototype.traverseCommentShort = function (commentShort) { return 0; };\n        CountBlockMoves.prototype.traverseCommentLong = function (commentLong) { return 0; };\n        return CountBlockMoves;\n    }(Up));\n    Traversal.CountBlockMoves = CountBlockMoves;\n    var StructureEquals = /** @class */ (function (_super) {\n        __extends(StructureEquals, _super);\n        function StructureEquals() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        StructureEquals.prototype.traverseSequence = function (sequence, dataDown) {\n            if (!(dataDown instanceof algorithm_1.Sequence)) {\n                return false;\n            }\n            if (sequence.nestedAlgs.length !== dataDown.nestedAlgs.length) {\n                return false;\n            }\n            for (var i = 0; i < sequence.nestedAlgs.length; i++) {\n                if (!this.traverse(sequence.nestedAlgs[i], dataDown.nestedAlgs[i])) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        StructureEquals.prototype.traverseGroup = function (group, dataDown) {\n            return (dataDown instanceof algorithm_1.Group) && this.traverse(group.nestedAlg, dataDown.nestedAlg);\n        };\n        StructureEquals.prototype.traverseBlockMove = function (blockMove, dataDown) {\n            // TODO: Handle layers.\n            return dataDown instanceof algorithm_1.BlockMove &&\n                blockMove.base === dataDown.base &&\n                blockMove.amount === dataDown.amount;\n        };\n        StructureEquals.prototype.traverseCommutator = function (commutator, dataDown) {\n            return (dataDown instanceof algorithm_1.Commutator) &&\n                this.traverse(commutator.A, dataDown.A) &&\n                this.traverse(commutator.B, dataDown.B);\n        };\n        StructureEquals.prototype.traverseConjugate = function (conjugate, dataDown) {\n            return (dataDown instanceof algorithm_1.Conjugate) &&\n                this.traverse(conjugate.A, dataDown.A) &&\n                this.traverse(conjugate.B, dataDown.B);\n        };\n        StructureEquals.prototype.traversePause = function (pause, dataDown) {\n            return dataDown instanceof algorithm_1.Pause;\n        };\n        StructureEquals.prototype.traverseNewLine = function (newLine, dataDown) {\n            return dataDown instanceof algorithm_1.NewLine;\n        };\n        StructureEquals.prototype.traverseCommentShort = function (commentShort, dataDown) {\n            return (dataDown instanceof algorithm_1.CommentShort) && (commentShort.comment == dataDown.comment);\n        };\n        StructureEquals.prototype.traverseCommentLong = function (commentLong, dataDown) {\n            return (dataDown instanceof algorithm_1.CommentShort) && (commentLong.comment == dataDown.comment);\n        };\n        return StructureEquals;\n    }(DownUp));\n    Traversal.StructureEquals = StructureEquals;\n    // TODO: Test that inverses are bijections.\n    var CoalesceMoves = /** @class */ (function (_super) {\n        __extends(CoalesceMoves, _super);\n        function CoalesceMoves() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        CoalesceMoves.prototype.sameBlock = function (moveA, moveB) {\n            // TODO: Handle layers\n            return moveA.base === moveB.base;\n        };\n        CoalesceMoves.prototype.traverseSequence = function (sequence) {\n            var coalesced = [];\n            for (var _i = 0, _a = sequence.nestedAlgs; _i < _a.length; _i++) {\n                var part = _a[_i];\n                if (!(part instanceof algorithm_1.BlockMove)) {\n                    coalesced.push(this.traverse(part));\n                }\n                else if (coalesced.length > 0) {\n                    var last = coalesced[coalesced.length - 1];\n                    if (last instanceof algorithm_1.BlockMove &&\n                        this.sameBlock(last, part)) {\n                        // TODO: This is cube-specific. Perhaps pass the modules as DataDown?\n                        var amount = last.amount + part.amount;\n                        coalesced.pop();\n                        if (amount !== 0) {\n                            // We could modify the last element instead of creating a new one,\n                            // but this is safe against shifting coding practices.\n                            // TODO: Figure out if the shoot-in-the-foot risk\n                            // modification is worth the speed.\n                            coalesced.push(new algorithm_1.BlockMove(part.base, amount));\n                        }\n                    }\n                    else {\n                        coalesced.push(part);\n                    }\n                }\n                else {\n                    coalesced.push(part);\n                }\n            }\n            return new algorithm_1.Sequence(coalesced);\n        };\n        CoalesceMoves.prototype.traverseGroup = function (group) { return group; };\n        CoalesceMoves.prototype.traverseBlockMove = function (blockMove) { return blockMove; };\n        CoalesceMoves.prototype.traverseCommutator = function (commutator) { return commutator; };\n        CoalesceMoves.prototype.traverseConjugate = function (conjugate) { return conjugate; };\n        CoalesceMoves.prototype.traversePause = function (pause) { return pause; };\n        CoalesceMoves.prototype.traverseNewLine = function (newLine) { return newLine; };\n        CoalesceMoves.prototype.traverseCommentShort = function (commentShort) { return commentShort; };\n        CoalesceMoves.prototype.traverseCommentLong = function (commentLong) { return commentLong; };\n        return CoalesceMoves;\n    }(Up));\n    Traversal.CoalesceMoves = CoalesceMoves;\n    var Concat = /** @class */ (function (_super) {\n        __extends(Concat, _super);\n        function Concat() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        Concat.prototype.concatIntoSequence = function (A, B) {\n            var nestedAlgs = A.slice();\n            if (B instanceof algorithm_1.Sequence) {\n                nestedAlgs = nestedAlgs.concat(B.nestedAlgs);\n            }\n            else {\n                nestedAlgs.push(B);\n            }\n            return new algorithm_1.Sequence(nestedAlgs);\n        };\n        Concat.prototype.traverseSequence = function (sequence, dataDown) { return this.concatIntoSequence(sequence.nestedAlgs, dataDown); };\n        Concat.prototype.traverseGroup = function (group, dataDown) { return this.concatIntoSequence([group], dataDown); };\n        Concat.prototype.traverseBlockMove = function (blockMove, dataDown) { return this.concatIntoSequence([blockMove], dataDown); };\n        Concat.prototype.traverseCommutator = function (commutator, dataDown) { return this.concatIntoSequence([commutator], dataDown); };\n        Concat.prototype.traverseConjugate = function (conjugate, dataDown) { return this.concatIntoSequence([conjugate], dataDown); };\n        Concat.prototype.traversePause = function (pause, dataDown) { return this.concatIntoSequence([pause], dataDown); };\n        Concat.prototype.traverseNewLine = function (newLine, dataDown) { return this.concatIntoSequence([newLine], dataDown); };\n        Concat.prototype.traverseCommentShort = function (commentShort, dataDown) { return this.concatIntoSequence([commentShort], dataDown); };\n        Concat.prototype.traverseCommentLong = function (commentLong, dataDown) { return this.concatIntoSequence([commentLong], dataDown); };\n        return Concat;\n    }(DownUp));\n    Traversal.Concat = Concat;\n    var ToString = /** @class */ (function (_super) {\n        __extends(ToString, _super);\n        function ToString() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        ToString.prototype.repetitionSuffix = function (amount) {\n            var absAmount = Math.abs(amount);\n            var s = \"\";\n            if (absAmount !== 1) {\n                s += String(absAmount);\n            }\n            if (absAmount !== amount) {\n                s += \"'\";\n            }\n            return s;\n        };\n        ToString.prototype.traverseSequence = function (sequence) {\n            var _this = this;\n            return sequence.nestedAlgs.map(function (a) { return _this.traverse(a); }).join(\" \");\n        };\n        ToString.prototype.traverseGroup = function (group) { return \"(\" + group.nestedAlg + \")\" + this.repetitionSuffix(group.amount); };\n        ToString.prototype.traverseBlockMove = function (blockMove) { return blockMove.base + this.repetitionSuffix(blockMove.amount); };\n        ToString.prototype.traverseCommutator = function (commutator) { return \"[\" + commutator.A + \", \" + commutator.B + \"]\" + this.repetitionSuffix(commutator.amount); };\n        ToString.prototype.traverseConjugate = function (conjugate) { return \"[\" + conjugate.A + \": \" + conjugate.B + \"]\" + this.repetitionSuffix(conjugate.amount); };\n        // TODO: Remove spaces between repeated pauses (in traverseSequence)\n        ToString.prototype.traversePause = function (pause) { return \".\"; };\n        ToString.prototype.traverseNewLine = function (newLine) { return \"\\n\"; };\n        // TODO: Enforce being followed by a newline (or the end of the alg)?\n        ToString.prototype.traverseCommentShort = function (commentShort) { return \"//\" + commentShort.comment; };\n        // TODO: Sanitize `*/`\n        ToString.prototype.traverseCommentLong = function (commentLong) { return \"/*\" + commentLong.comment + \"*/\"; };\n        return ToString;\n    }(Up));\n    Traversal.ToString = ToString;\n    var Singleton;\n    (function (Singleton) {\n        Singleton.clone = new Clone();\n        Singleton.invert = new Invert();\n        Singleton.expand = new Expand();\n        Singleton.countBlockMoves = new CountBlockMoves();\n        Singleton.structureEquals = new StructureEquals();\n        Singleton.coalesceMoves = new CoalesceMoves();\n        Singleton.concat = new Concat();\n        Singleton.toString = new ToString();\n    })(Singleton = Traversal.Singleton || (Traversal.Singleton = {}));\n})(Traversal = exports.Traversal || (exports.Traversal = {}));\n\n\n//# sourceURL=webpack://alg/./traversal.ts?");

/***/ })

/******/ });
});